<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ToonKit - Fixed Sync</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script async defer src="https://apis.google.com/js/api.js"></script>
    <script async defer src="https://accounts.google.com/gsi/client"></script>

    <style>
        :root { --safe-top: env(safe-area-inset-top); --safe-bottom: env(safe-area-inset-bottom); }
        body, html { 
            margin: 0; padding: 0; height: 100%; width: 100%; 
            overflow: hidden; background-color: #FFF5F7; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            -webkit-user-select: none;
        }
        #root { height: 100%; width: 100%; }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        .spinner { 
            width: 20px; height: 20px; 
            border: 2px solid rgba(219, 39, 119, 0.2); border-top-color: #db2777; 
            border-radius: 50%; animation: spin 0.8s linear infinite; 
        }
        .pt-safe { padding-top: max(1.25rem, var(--safe-top)); }
        .pb-safe { padding-bottom: max(1.5rem, var(--safe-bottom)); }
        .scroll-container { 
            height: 100%; overflow-y: auto; 
            -webkit-overflow-scrolling: touch; 
            scrollbar-width: none;
        }
        .scroll-container::-webkit-scrollbar { display: none; }
        
        .pin-dot { width: 14px; height: 14px; border-radius: 50%; transition: all 0.25s; }
        .pin-dot.active { background-color: #db2777; transform: scale(1.2); }
        .pin-dot.inactive { background-color: #fce7f3; border: 1.5px solid #fbcfe8; }
        
        /* 완료 상태 스타일 */
        .toon-card-completed {
            background-color: #F1F5F9 !important;
            border-color: #E2E8F0 !important;
            opacity: 0.75;
        }
        .toon-title-completed {
            text-decoration: line-through;
            color: #94A3B8 !important;
        }
        
        /* 체크박스 개선 */
        .check-box-hit {
            padding: 8px;
            margin: -8px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        const CLIENT_ID = '1088995464661-ft9gdmqcc90in7k5cdcussocote4mi92.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyBxvFtk2jiBisjoubvv2olJEgyoyNQ_k0w';
        const DISCOVERY_DOC = 'https://sheets.googleapis.com/$discovery/rest?version=v4';
        const SCOPES = 'https://www.googleapis.com/auth/spreadsheets';

        const App = () => {
            const [toons, setToons] = useState(() => {
                const saved = localStorage.getItem('toonkit_v3_data');
                return saved ? JSON.parse(saved).sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0)) : [];
            });
            
            const [isEditing, setIsEditing] = useState(false);
            const [currentToon, setCurrentToon] = useState({ id: null, title: '', pages: Array(10).fill(''), completed: false });
            const [isSyncing, setIsSyncing] = useState(false);
            const [isLoggedIn, setIsLoggedIn] = useState(false);
            const [spreadsheetId, setSpreadsheetId] = useState(localStorage.getItem('toonkit_sheet_id') || '');
            const [showSettings, setShowSettings] = useState(false);
            const [errorMsg, setErrorMsg] = useState('');
            
            const [savedPin, setSavedPin] = useState(localStorage.getItem('toonkit_pin') || '');
            const [isUnlocked, setIsUnlocked] = useState(false);
            const [pinInput, setPinInput] = useState('');
            const [isSettingPin, setIsSettingPin] = useState(false);

            const tokenClient = useRef(null);

            const initializeGoogleApi = async () => {
                try {
                    if (!window.gapi) return;
                    await new Promise(resolve => window.gapi.load('client', resolve));
                    await window.gapi.client.init({ apiKey: API_KEY, discoveryDocs: [DISCOVERY_DOC] });
                    const savedToken = localStorage.getItem('google_auth_token');
                    if (savedToken) {
                        window.gapi.client.setToken(JSON.parse(savedToken));
                        setIsLoggedIn(true);
                    }
                } catch (e) { console.error(e); }
            };

            useEffect(() => {
                const initGis = () => {
                    if (!window.google) return;
                    tokenClient.current = window.google.accounts.oauth2.initTokenClient({
                        client_id: CLIENT_ID, 
                        scope: SCOPES,
                        callback: async (resp) => {
                            if (resp.error) return;
                            localStorage.setItem('google_auth_token', JSON.stringify(resp));
                            setIsLoggedIn(true);
                            await loadFromSheets(true);
                        },
                    });
                };
                initializeGoogleApi();
                setTimeout(initGis, 1000);
            }, []);

            useEffect(() => {
                localStorage.setItem('toonkit_v3_data', JSON.stringify(toons));
                if (window.lucide) window.lucide.createIcons();
            }, [toons, isEditing, showSettings, isUnlocked]);

            const loadFromSheets = async (silent = false) => {
                if (!spreadsheetId || !isLoggedIn) return;
                setIsSyncing(true);
                try {
                    const ss = await window.gapi.client.sheets.spreadsheets.get({ spreadsheetId });
                    const sheetName = ss.result.sheets[0].properties.title;
                    const response = await window.gapi.client.sheets.spreadsheets.values.get({
                        spreadsheetId, range: `'${sheetName}'!A2:N200`,
                    });
                    const rows = response.result.values;
                    if (rows) {
                        const mapped = rows.filter(r => r[12]).map(r => ({
                            title: r[0] || "",
                            pages: r.slice(1, 11).map(p => p || ''),
                            completed: r[11] === "완료",
                            id: r[12],
                            updatedAt: r[13] ? parseInt(r[13]) : Date.now()
                        }));
                        setToons(mapped.sort((a, b) => b.updatedAt - a.updatedAt));
                        if (!silent) showToast("동기화 완료");
                    }
                } catch (e) { showToast("로드 실패"); }
                finally { setIsSyncing(false); }
            };

            const syncToSheets = async (updatedToons) => {
                if (!spreadsheetId || !isLoggedIn) return;
                setIsSyncing(true);
                try {
                    const ss = await window.gapi.client.sheets.spreadsheets.get({ spreadsheetId });
                    const sheetId = ss.result.sheets[0].properties.sheetId;
                    const sheetName = ss.result.sheets[0].properties.title;
                    
                    // 1. 전체 비우기 (더 확실한 동기화를 위해)
                    await window.gapi.client.sheets.spreadsheets.values.clear({
                        spreadsheetId, range: `'${sheetName}'!A2:N200`
                    });

                    // 2. 새로운 데이터 업로드
                    if (updatedToons.length > 0) {
                        const rows = updatedToons.map(t => [
                            t.title, ...t.pages, t.completed ? "완료" : "진행중", t.id, t.updatedAt
                        ]);
                        await window.gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId, range: `'${sheetName}'!A2`,
                            valueInputOption: 'USER_ENTERED',
                            resource: { values: rows }
                        });

                        // 3. 서식 적용 (중간줄)
                        const formatRequests = updatedToons.map((t, i) => ({
                            repeatCell: {
                                range: { sheetId, startRowIndex: i + 1, endRowIndex: i + 2, startColumnIndex: 0, endColumnIndex: 12 },
                                cell: { userEnteredFormat: { textFormat: { strikethrough: t.completed } } },
                                fields: "userEnteredFormat.textFormat.strikethrough"
                            }
                        }));
                        await window.gapi.client.sheets.spreadsheets.batchUpdate({
                            spreadsheetId, resource: { requests: formatRequests }
                        });
                    }
                    showToast("시트 업데이트 완료");
                } catch (e) { showToast("동기화 오류"); }
                finally { setIsSyncing(false); }
            };

            const saveToon = async () => {
                if (!currentToon.title.trim()) return;
                const now = Date.now();
                const newToon = currentToon.id 
                    ? { ...currentToon, updatedAt: now } 
                    : { ...currentToon, id: now.toString(), updatedAt: now };
                
                const newList = currentToon.id 
                    ? toons.map(t => t.id === currentToon.id ? newToon : t) 
                    : [newToon, ...toons];
                
                const sorted = newList.sort((a, b) => b.updatedAt - a.updatedAt);
                setToons(sorted);
                setIsEditing(false);
                await syncToSheets(sorted);
            };

            const deleteToon = async (id) => {
                if (!confirm("정말 삭제하시겠습니까? 시트의 데이터도 삭제됩니다.")) return;
                const newList = toons.filter(t => t.id !== id);
                setToons(newList);
                
                // 시트에서 행 삭제 처리를 위해 전체 데이터를 다시 덮어쓰기함
                await syncToSheets(newList);
            };

            const toggleComplete = async (e, id) => {
                e.stopPropagation(); // 카드 클릭 방지
                const newList = toons.map(t => 
                    t.id === id ? { ...t, completed: !t.completed, updatedAt: Date.now() } : t
                ).sort((a, b) => b.updatedAt - a.updatedAt);
                setToons(newList);
                await syncToSheets(newList);
            };

            const showToast = (msg) => {
                setErrorMsg(msg);
                setTimeout(() => setErrorMsg(''), 2000);
            };

            const handlePinPress = (num) => {
                if (pinInput.length >= 4) return;
                const next = pinInput + num;
                setPinInput(next);
                if (next.length === 4) {
                    if (isSettingPin) {
                        localStorage.setItem('toonkit_pin', next);
                        setSavedPin(next);
                        setIsSettingPin(false);
                        setIsUnlocked(true);
                        setPinInput('');
                    } else if (next === savedPin) {
                        setIsUnlocked(true);
                        setPinInput('');
                        loadFromSheets(true);
                    } else {
                        showToast("PIN이 틀렸습니다.");
                        setPinInput('');
                    }
                }
            };

            // --- 렌더링 파트 ---
            if ((savedPin && !isUnlocked) || isSettingPin) {
                return (
                    <div className="h-full w-full flex flex-col items-center justify-center bg-[#FFF5F7] fixed inset-0 z-[100]">
                        <div className="text-center mb-10">
                            <div className="w-20 h-20 bg-pink-500 rounded-[2.5rem] flex items-center justify-center text-white mx-auto mb-6 shadow-xl">
                                <i data-lucide={isSettingPin ? "shield" : "lock"} className="w-8 h-8"></i>
                            </div>
                            <h2 className="text-2xl font-black text-slate-800">{isSettingPin ? "보안 설정" : "잠금 해제"}</h2>
                        </div>
                        <div className="flex gap-5 mb-14">
                            {[0,1,2,3].map(i => <div key={i} className={`pin-dot ${pinInput.length > i ? 'active' : 'inactive'}`}></div>)}
                        </div>
                        <div className="grid grid-cols-3 gap-6 w-64">
                            {[1,2,3,4,5,6,7,8,9].map(n => <button key={n} onClick={() => handlePinPress(n.toString())} className="h-16 w-16 rounded-2xl bg-white text-2xl font-bold shadow-sm active:bg-pink-100 flex items-center justify-center text-slate-700">{n}</button>)}
                            <div className="h-16 w-16"></div>
                            <button onClick={() => handlePinPress('0')} className="h-16 w-16 rounded-2xl bg-white text-2xl font-bold shadow-sm flex items-center justify-center text-slate-700">0</button>
                            <button onClick={() => setPinInput('')} className="h-16 w-16 flex items-center justify-center text-slate-300"><i data-lucide="delete"></i></button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full w-full flex flex-col bg-[#FFF5F7]">
                    <header className="px-6 pt-safe pb-4 flex justify-between items-center bg-white border-b border-pink-100 shadow-sm shrink-0">
                        <div className="flex items-center gap-2">
                            {isEditing && <button onClick={() => setIsEditing(false)} className="text-pink-500 p-2"><i data-lucide="arrow-left"></i></button>}
                            <h1 className="text-2xl font-black text-pink-600 tracking-tighter">ToonKit</h1>
                        </div>
                        <div className="flex gap-2">
                            <button onClick={() => setShowSettings(!showSettings)} className={`p-2 rounded-xl ${isLoggedIn ? 'text-pink-500 bg-pink-50' : 'text-slate-300'}`}><i data-lucide="settings"></i></button>
                            {!isEditing && <button onClick={() => {setCurrentToon({id:null, title:'', pages:Array(10).fill(''), completed:false}); setIsEditing(true);}} className="bg-pink-500 text-white px-5 py-2 rounded-xl font-black text-sm shadow-md active:scale-95">새 콘티</button>}
                        </div>
                    </header>

                    <main className="flex-1 scroll-container px-6 py-6">
                        {showSettings && (
                            <div className="mb-8 p-6 bg-white rounded-[2rem] shadow-xl border border-pink-50 animate-in slide-in-from-top-2">
                                <button onClick={() => loadFromSheets()} className="w-full py-4 bg-blue-50 text-blue-600 rounded-2xl font-bold mb-3 flex items-center justify-center gap-2">
                                    <i data-lucide="refresh-cw" className={isSyncing ? "animate-spin" : ""}></i> 시트 동기화
                                </button>
                                <button onClick={() => tokenClient.current.requestAccessToken()} className={`w-full py-4 rounded-2xl font-bold mb-3 flex items-center justify-center gap-2 ${isLoggedIn ? 'bg-green-50 text-green-600' : 'bg-pink-50 text-pink-600'}`}>
                                    <i data-lucide="log-in"></i> {isLoggedIn ? "구글 연동 완료" : "구글 로그인"}
                                </button>
                                <input type="text" value={spreadsheetId} onChange={(e) => {setSpreadsheetId(e.target.value); localStorage.setItem('toonkit_sheet_id', e.target.value);}} placeholder="Spreadsheet ID 입력" className="w-full p-4 bg-slate-50 rounded-2xl text-sm outline-none border-2 border-transparent focus:border-pink-200" />
                                <button onClick={() => setShowSettings(false)} className="w-full mt-4 py-4 bg-pink-500 text-white rounded-2xl font-black">닫기</button>
                            </div>
                        )}

                        {isEditing ? (
                            <div className="space-y-4 pb-40">
                                <div className="flex items-center gap-4 bg-white p-5 rounded-2xl border border-pink-50 shadow-sm">
                                    <button onClick={() => setCurrentToon({...currentToon, completed: !currentToon.completed})} className={`w-9 h-9 rounded-lg border-2 flex items-center justify-center transition-all ${currentToon.completed ? 'bg-green-500 border-green-500 text-white shadow-lg shadow-green-100' : 'border-slate-200 text-transparent'}`}>
                                        <i data-lucide="check" className="w-6 h-6 stroke-[4]"></i>
                                    </button>
                                    <input type="text" value={currentToon.title} onChange={(e) => setCurrentToon({...currentToon, title:e.target.value})} placeholder="에피소드 제목" className={`flex-1 text-xl font-black outline-none ${currentToon.completed ? 'line-through text-slate-400' : 'text-slate-800'}`} />
                                </div>
                                {currentToon.pages.map((p, i) => (
                                    <div key={i} className={`p-5 rounded-[2rem] border border-pink-50 shadow-sm transition-all ${currentToon.completed ? 'bg-slate-50 opacity-60' : 'bg-white'}`}>
                                        <p className="text-[10px] font-black text-pink-300 mb-2 tracking-widest uppercase">{i === 0 ? "COVER" : `PAGE ${i}`}</p>
                                        <textarea value={p} onChange={(e) => {const next = [...currentToon.pages]; next[i] = e.target.value; setCurrentToon({...currentToon, pages:next});}} className="w-full min-h-[140px] outline-none text-slate-700 resize-none leading-relaxed text-base bg-transparent" placeholder="대사 및 장면 묘사..." />
                                    </div>
                                ))}
                                <div className="fixed bottom-10 left-6 right-6">
                                    <button onClick={saveToon} disabled={isSyncing} className="w-full py-5 rounded-[2.2rem] font-black text-lg bg-pink-600 text-white shadow-2xl flex items-center justify-center gap-3 active:scale-95 disabled:bg-slate-300 transition-all">
                                        {isSyncing ? <div className="spinner" style={{borderTopColor:'#fff'}}></div> : <i data-lucide="upload-cloud"></i>}
                                        {isSyncing ? "동기화 중..." : "저장하기"}
                                    </button>
                                </div>
                            </div>
                        ) : (
                            <div className="grid gap-5 pb-24">
                                {toons.map(t => (
                                    <div key={t.id} onClick={() => {setCurrentToon(t); setIsEditing(true);}} className={`p-6 rounded-[2.5rem] border-2 shadow-sm transition-all relative ${t.completed ? 'toon-card-completed' : 'bg-white border-white'}`}>
                                        <div className="flex justify-between items-start mb-5">
                                            <div className="flex items-center gap-4 pr-10">
                                                <div className="check-box-hit" onClick={(e) => toggleComplete(e, t.id)}>
                                                    <div className={`w-8 h-8 rounded-lg border-2 flex items-center justify-center transition-all ${t.completed ? 'bg-green-500 border-green-500 text-white shadow-lg shadow-green-100' : 'border-slate-200 text-transparent bg-white'}`}>
                                                        <i data-lucide="check" className="w-5 h-5 stroke-[4]"></i>
                                                    </div>
                                                </div>
                                                <h2 className={`font-black text-lg truncate tracking-tight ${t.completed ? 'toon-title-completed' : 'text-slate-800'}`}>{t.title}</h2>
                                            </div>
                                            <button onClick={(e) => { e.stopPropagation(); deleteToon(t.id); }} className="absolute top-6 right-6 p-2 text-slate-200 hover:text-pink-500">
                                                <i data-lucide="trash-2" className="w-5 h-5"></i>
                                            </button>
                                        </div>
                                        <div className="flex gap-1.5">
                                            {t.pages.map((p, idx) => <div key={idx} className={`h-1.5 flex-1 rounded-full ${p && p.trim() ? (t.completed ? 'bg-slate-300' : 'bg-pink-500') : 'bg-pink-50/50'}`} />)}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </main>

                    {errorMsg && <div className="fixed bottom-24 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-6 py-3 rounded-full text-xs font-bold z-[60] shadow-xl">{errorMsg}</div>}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>